# Neural Networks (EEE950)
# Pedro Vinicius A. B. de Venancio
# Radial Basis Function networks (RBFs)

# X: input matrix with dimension n_samples x n_features
# Y: labels vector with dimension n_samples x 1
# k_clusters: number of clusters
# cluster: list containing all clusters with their respective samples
# centroid: matrix to store centroids of all clusters (k_clusters x n_features)

# Import libraries
library(ggplot2)
library(latex2exp)
library(corpcor)

# Gaussian activation function
gaussian <- function(v, sigma){
  return(exp(-v/(2*sigma^2)))
}

# Heuristic to estimate width of Gaussian kernel
width_estimate <- function(centroid){
  
  # Number of clusters
  k_clusters <- dim(as.matrix(centroid))[1]
  
  # Calculate maximum distance between two clusters
  max_dist <- 0
  for(i in 1:k_clusters){
    for(j in 1:k_clusters){
      dist <- norm(as.matrix(centroid[i,] - centroid[j,]))
      if(!is.na(dist) && dist > max_dist){
        max_dist <- dist
      }
    }
  }
  # Calculate width of Gaussian kernel
  sigma = max_dist/sqrt(2*k_clusters)
  
  return(sigma)
  
}

# Training algorithm of radial basis function networks
rbf <- function(X, Y, cluster, k_clusters){
  
  # Number of samples
  n_samples <- dim(X)[1]
  # Number of features
  n_features <- dim(X)[2]
  
  # Matrix to store centroids of all clusters (k_clusters x n_features)
  centroid <- matrix(nrow = k_clusters, ncol = n_features)
  
  # Compute cluster centroids
  for(k in 1:k_clusters){
    centroid[k,] <- colMeans(do.call(rbind, cluster[k]))
  }
  
  # Estimate width of Gaussian kernels
  sigma <- width_estimate(centroid)
  
  # Mapping from input layer to hidden layer (n_samples x k_clusters + 1)
  A_1 <- matrix(nrow = n_samples, ncol = k_clusters)
  for(i in 1:n_samples){
    for(j in 1:k_clusters){
      v <- norm(X[i,] - as.matrix(centroid[j,]))
      A_1[i,j] <- gaussian(v, sigma)
    }
  }
  A_1 <- cbind(1, A_1)
  
  # Compute weights of the hidden layer ((k_clusters + 1) x 1)
  W <- pseudoinverse(A_1) %*% Y
  
  return(W)
  
}

# Contour function
contour_plot2D <- function(X, W, cluster, axis_lim, step = 0.1){
  
  # Number of samples
  n_samples <- dim(X)[1]
  # Number of features
  n_features <- dim(X)[2]
  # Number of clusters
  k_clusters <- dim(W)[1] - 1
  
  # Matrix to store centroids of all clusters (k_clusters x n_features)
  centroid <- matrix(nrow = k_clusters, ncol = n_features)

  # Compute cluster centroids
  for(k in 1:k_clusters){
    centroid[k,] <- colMeans(do.call(rbind, cluster[k]))
  }
  
  # Estimate width of Gaussian kernels
  sigma <- width_estimate(centroid)
  
  # Make grid
  grid <- seq(axis_lim[1], axis_lim[2], step)
  grid_size <- length(grid)
  
  # Contour generated by radial basis function network
  contour <- matrix(nrow = grid_size, ncol = grid_size)
  A_1 <- matrix(1, ncol = k_clusters, nrow = 1)
  for (i in 1:grid_size){
    for(j in 1:grid_size){
      x1 <- grid[i]
      x2 <- grid[j]
      x1x2 <- as.matrix((cbind(x1, x2)))
      for(k in 1:k_clusters){
        v <- norm(x1x2 - t(as.matrix(centroid[k,])))
        A_1[k] <- gaussian(v, sigma)
      }
      contour[i,j] <- cbind(1, A_1) %*% W
    }
  }
  
  # Contour plot from a grid of points
  persp(grid, grid, contour)
  contour(grid, grid, contour, xlim = c(axis_lim[1], axis_lim[2]), ylim = c(axis_lim[1], axis_lim[2]), xlab = TeX('x_1'), ylab = TeX('x_2'), nlevels = 1)
  # Plot data
  points(X[1:n_samples/2, 1], X[1:n_samples/2, 2], col = 'blue')
  points(X[(n_samples/2+1):n_samples,1], X[(n_samples/2+1):n_samples, 2], col = 'red')
  
}
